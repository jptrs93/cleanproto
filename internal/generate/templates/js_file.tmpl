{{- range .Typedefs}}
{{.}}

{{- end}}
import {Reader, Writer} from "protobufjs/minimal";

const WIRE = {
    VARINT: 0,
    FIXED64: 1,
    LDELIM: 2,
    FIXED32: 5
};

const tag = (field, wire) => (field << 3) | wire;

{{range .Messages}}
{{.WriteFunc}}

{{.EncodeFunc}}

{{.DecodeMessageFunc}}

{{.DecodeFunc}}

{{end}}
{{- if .NeedsReadInt64}}
function readInt64(reader, method) {
    const value = reader[method]();
    if (typeof value === "number") {
        return value;
    }
    return value.toNumber();
}
{{- end}}
{{- if .NeedsReadInt64BigInt}}
function readInt64BigInt(reader, method) {
    const value = reader[method]();
    if (typeof value === "number") {
        return BigInt(Math.trunc(value));
    }
    if (typeof value === "bigint") {
        return value;
    }
    return BigInt(value.toString());
}
{{- end}}
{{- if .NeedsTimestamp}}
function writeTimestamp(value, writer) {
    if (!(value instanceof Date)) {
        return;
    }
    const ms = value.getTime();
    const seconds = Math.floor(ms / 1000);
    const nanos = Math.floor((ms - (seconds * 1000)) * 1e6);
    writer.uint32(tag(1, WIRE.VARINT)).int64(seconds);
    if (nanos !== 0) {
        writer.uint32(tag(2, WIRE.VARINT)).int32(nanos);
    }
}

function decodeTimestampMessage(reader, length) {
    const end = length === undefined ? reader.len : reader.pos + length;
    let seconds = 0;
    let nanos = 0;
    while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
            case 1: {
                seconds = readInt64(reader, "int64");
                break;
            }
            case 2: {
                nanos = reader.int32();
                break;
            }
            default:
                reader.skipType(tag & 7);
        }
    }
    return new Date((seconds * 1000) + Math.floor(nanos / 1e6));
}
{{- end}}
{{- if .NeedsTimestampNative}}
function writeTimestampFromMillis(value, writer) {
    if (value === undefined || value === null || value === 0) {
        return;
    }
    const ms = Math.trunc(value);
    const seconds = Math.floor(ms / 1000);
    const nanos = Math.floor((ms - (seconds * 1000)) * 1e6);
    writer.uint32(tag(1, WIRE.VARINT)).int64(seconds);
    if (nanos !== 0) {
        writer.uint32(tag(2, WIRE.VARINT)).int32(nanos);
    }
}

function decodeTimestampMillisMessage(reader, length) {
    const end = length === undefined ? reader.len : reader.pos + length;
    let seconds = 0;
    let nanos = 0;
    while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
            case 1: {
                seconds = readInt64(reader, "int64");
                break;
            }
            case 2: {
                nanos = reader.int32();
                break;
            }
            default:
                reader.skipType(tag & 7);
        }
    }
    return (seconds * 1000) + Math.floor(nanos / 1e6);
}

function writeTimestampFromBigInt(value, writer) {
    if (value === undefined || value === null || value === 0n) {
        return;
    }
    const ms = value;
    const seconds = ms / 1000n;
    const nanos = Number((ms % 1000n) * 1000000n);
    writer.uint32(tag(1, WIRE.VARINT)).int64(seconds.toString());
    if (nanos !== 0) {
        writer.uint32(tag(2, WIRE.VARINT)).int32(nanos);
    }
}

function decodeTimestampBigIntMessage(reader, length) {
    const end = length === undefined ? reader.len : reader.pos + length;
    let seconds = 0n;
    let nanos = 0;
    while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
            case 1: {
                seconds = readInt64BigInt(reader, "int64");
                break;
            }
            case 2: {
                nanos = reader.int32();
                break;
            }
            default:
                reader.skipType(tag & 7);
        }
    }
    return (seconds * 1000n) + (BigInt(nanos) / 1000000n);
}
{{- end}}
{{- if .NeedsDuration}}
function writeDuration(value, writer) {
    if (value === undefined || value === null || value === 0) {
        return;
    }
    const totalNanos = Math.trunc(value * 1e6);
    const seconds = Math.trunc(totalNanos / 1e9);
    const nanos = totalNanos - (seconds * 1e9);
    writer.uint32(tag(1, WIRE.VARINT)).int64(seconds);
    if (nanos !== 0) {
        writer.uint32(tag(2, WIRE.VARINT)).int32(nanos);
    }
}

function decodeDurationMessage(reader, length) {
    const end = length === undefined ? reader.len : reader.pos + length;
    let seconds = 0;
    let nanos = 0;
    while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
            case 1: {
                seconds = readInt64(reader, "int64");
                break;
            }
            case 2: {
                nanos = reader.int32();
                break;
            }
            default:
                reader.skipType(tag & 7);
        }
    }
    return (seconds * 1000) + (nanos / 1e6);
}
{{- end}}
{{- if .NeedsDurationBigInt}}
function writeDurationFromBigInt(value, writer) {
    if (value === undefined || value === null || value === 0n) {
        return;
    }
    const totalNanos = value * 1000000n;
    const seconds = totalNanos / 1000000000n;
    const nanos = Number(totalNanos - (seconds * 1000000000n));
    writer.uint32(tag(1, WIRE.VARINT)).int64(seconds.toString());
    if (nanos !== 0) {
        writer.uint32(tag(2, WIRE.VARINT)).int32(nanos);
    }
}

function decodeDurationBigIntMessage(reader, length) {
    const end = length === undefined ? reader.len : reader.pos + length;
    let seconds = 0n;
    let nanos = 0;
    while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
            case 1: {
                seconds = readInt64BigInt(reader, "int64");
                break;
            }
            case 2: {
                nanos = reader.int32();
                break;
            }
            default:
                reader.skipType(tag & 7);
        }
    }
    return (seconds * 1000n) + (BigInt(nanos) / 1000000n);
}
{{- end}}
